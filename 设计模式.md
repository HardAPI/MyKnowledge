# 设计模式

### 工厂模式

**意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

**主要解决：**接口选择的问题。

**何时使用：**我们明确地计划不同条件下创建不同实例时。

**如何解决：**让其子类实现工厂接口，返回的也是一个抽象的产品。

**关键代码：**创建过程在其子类执行。

一般用于创建复杂对象，如果是简单对象没必要增加麻烦。



### 抽象工厂

和工厂模式相比更加抽象，建立了一个***“联合工厂”***，由联合工厂实例化具体工厂，再执行工厂的细节。



### 单例模式

保证一个类只有**一个实例**，并且提供了外界访问该实例的方式。

**意图：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。

**主要解决：**一个全局使用的类频繁地创建与销毁。

**何时使用：**当您想控制实例数目，节省系统资源的时候。

**如何解决：**判断系统是否已经有这个单例，如果有则返回，如果没有则创建。

**关键代码：**构造函数是私有的。

**实现方法**：

- **懒汉式、线程不安全**
  - 定义一个静态的函数来获取实例，当实例不存在时创建。
- **懒汉、线程安全**
  - 和上述实现方法一样，但是加锁 synchronized 保证单例。但是加锁会影响效率。
- **饿汉式**
  - 添加该类**静态成员变量**作为唯一实例（private static Singleton instance = new Singleton();  ）
  - 类加载时即初始化，浪费内存
- **双检锁/双重校验锁（DCL，即 double-checked locking）**

```Java
public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (singleton == null) {  
        synchronized (Singleton.class) {  
        if (singleton == null) {  
            singleton = new Singleton();  
        }  
        }  
    }  
    return singleton;  
    }  
}
```

- **登记式/静态内部类**

```
public class Singleton {  
    private static class SingletonHolder {  
    private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
    return SingletonHolder.INSTANCE;  
    }  
}
```





### 命令模式

请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。相当于解耦了输入和操作对象之间的关系，把命令独立了开来变成对应的类。



###  建造者模式

使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

例如一份麦当劳特价套餐一般包含汉堡、薯条、饮料，但这三者都有多种选择，这里就可以用建造者模式构建套餐。当然这个例子的组件之间关系还是算松散，如果要制造汽车，必然是先建好框架才能安装轮子，这里框架和轮子虽然能够有多个选择，但是创建顺序则是固定的。建造者模式可以交方便地控制这些顺序。



### 适配器模式

适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。

说白了就是转换插座，因为原本类没有提供某个接口，不想直接修改这个类的话，就写一个中间类实现利用该类原有的方法来实现这个接口。所以适配器模式的实现方法有两种，一种是新类继承目标类同时实现新的接口，另一种是新类包含目标类成员变量，通过成员变量来实现接口。



### 享元模式

享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。

例如你要渲染一片森林，绝大部分的树都是基于一个模型，那样可以仅仅将树的模型传入一次gpu重复使用，而不是每渲染一棵树就传入一次。这个模式某些情况下需要硬件支持，就如刚刚的例子。



### 观察者模式

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

抽象出观察者接口，然后让观察者实现接口，而被观察者维护一个观察者列表，每次操作都会把信息告诉观察者。

例如在游戏中有一个特定行为达到次数的成就系统，可以将成就系统变成观察者，实现行为的类作为被观察者维护观察者列表，每次都通知所有观察者。



### 原型模式

用于创建重复的对象，同时又能保证性能。

就是实现clone方法，这里需要深复制。

### 对象池模式

在程序运行中，有一些对象初始化和释放时代价昂贵，如果频繁创建和释放这些对象会严重影响程序运行效率。这时候，维护一个对象池，在程序加载时将所有对象初始化、然后在程序结束时再统一释放，就可以放心使用对象而不需要考虑对性能的影响。

基本实现如下：

```c++
class A{
	bool isUsing;
	int myData;
	A(){
		isUsing=false;
	}
	void init(int i){
		myData=i;
		isUsing=true;
	}
	void dosomething(){}
}
class Apool{
	A pool[POOLSIZE];
	Apool(){}
	A* newObject(int i){
		for(int i=0;i<POOLSIZE;i++){
			if(!pool[i].isUsing){
				pool[i].init(i);
				return &pool[i];
			}
		}
		return NULL;
	}
}
```

这样就大致完成了一个简单的对象池，仅提供了“创建对象”而没有提供“销毁对象”（简单来说可能只是拨弄一下标志位isUsing），但是实际应用时远比这复杂，需要考虑销毁时需不需要清空里面的数据（本例指的是myData），不清除会不会对之后“创建”在该位置的新对象影响呢？

注意到这里对象池的大小是提供硬编码POOLSIZE来限制大小，实际应用可以考虑动态大小，但是还是得衡量最初的问题：使用这个模式是为了减小频繁初始化与销毁对象带来的性能影响，在程序运行过程中动态管理对象池带来额外的初始化和释放会不会影响性能。这个模式很大程度上是使用空间换时间，使用对象池意味着程序从头到尾都要存在在内存中，如果过大，则可能从空间上影响性能，如果过小，则不够使用。例子中的对象池仅仅提供了一种类型的对象，如果对象池需要为多个类型提供对象，那意味着池内的每一块内存大小都必须为最大的类型的大小，就像用行李箱装钱包，这会带来碎片浪费空间。（可以让管理器持有许多块尺寸不同的池。当你申请时，管理器自动将合适大小的块返回给你）

还有一个问题，在上面的代码里面你会发现每次“新建对象”，都需要遍历池内元素寻找空闲对象，复杂度为O(n)，这显然不能被希望性能优化的我们所接受。最容易想到的解决方法是维护一张“空闲表”，那样寻找空闲对象的复杂度就是O(1)，释放时也只需要加进表内即可。但这又使用了额外的空间。也许你会这么想，如果能够使用空闲对象的空间就好了，不用白不用。这时候union就派上用场了。

```c++
class A{
	bool isUsing;
	union{ 
		int myData;
		A* nextFree;
	}
	A(){
		isUsing=false;
	}
	void init(int i){
		myData=i;
		isUsing=true;
	}
	void dosomething(){}
}
class Apool{
	A pool[POOLSIZE];
	A* freeTable;
	Apool(){
		for(int i=0;i<POOLSIZE-1;i++){
			pool[i].nextFree=&pool[i+1];
		}
		pool[POOLSIZE-1].nextFree=NULL;
	}
	A* newObject(int i){
		A* a=freeTable;
		if(freeTable)
			freeTasble=freeTable->nextFree;
		A->init(i);
		return a;
	}
}
```

这样就活用空间，使“新建对象”复杂度降至O(1)了。
