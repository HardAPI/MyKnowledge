# 计算机组成

### 1.虚拟内存

​	https://zhuanlan.zhihu.com/p/96098896



### 2.数据局部性

在任意数据结构的生命周期内，不仅执行不同操作的概率往往极不均衡，而且各操作之间具有极强的相关性，并在整体上呈现出极强的规律性。

1. 刚刚被访问过的元素，极有可能在不久之后**再次**被访问到；
2. 将被访问的下一个元素，极有可能就处于之前被访问过的某个元素的**附近**；

在现代计算机一般配有多级高速缓存，中央处理器寻找数据会先在高速缓存中寻找，找不到才一级一级下去到主存和硬盘。根据数据局部性原理，如果CPU需要从主存中读取一个数据，有可能会把数据附近的其他数据也加载进高速缓存。而当新的数据到达一个存储硬件，这个存储硬件可能已经存满，这时候就要通过某种置换策略来置换已经有的数据，如**FIFO**、**LRU**、**LFU**。当然了，最理想还是**OPT**(理想置换算法)，移出以后永远不会再访问的数据。

在编程中，有意识地注意上面这些机制，能够带来程序性能的提升，例如：

​	假设这时候计算机上除了主存外，只有一级128字节的高速缓存，每次从主存读数据时，计算机会顺便把数组相邻的32个元素加载进高速缓存。

```
int a[100]={0};
int b[100]={0};
int c[100]={0};
int count=0;
for(int i=0;i<100;i++){
	count+=a[i];
	count+=c[i];
	count+=b[i];
}
```

你会发现，上述一段代码中，高速缓存全部失效，换言之，高速缓存完全没有起到加快读取速度的作用。

考虑下一段代码：

```
for(int i=0;i<100;i++){
	count+=a[i];
}
for(int i=0;i<100;i++){
	count+=b[i];
}
for(int i=0;i<100;i++){
	count+=c[i];
}
```

你会发现，最好情况下，平均CPU计算每32次,才访问一次内存，高速缓存带来的加速就体现了。

当然，上面的条件比较极端，实际工作时可能并不是这样，但我们编程时要有这个留意的点。

另外，如果上述情况出现在硬盘到主存上，例如虚拟内存，频繁出现**缺页中断**会给程序性能带来更糟糕的灾难，称为**缺页抖动**。

考虑下面两段循环：

```
int a[LENGTH][LENGTH];
int sum=0;
for(int i=0;i<LENGTH;i++)
	for(int j=0;j<LENGTH;j++)
		sum+=a[i][j];

for(int i=0;i<LENGTH;i++)
	for(int j=0;j<LENGTH;j++)
		sum+=a[j][i];

```

当LENGTH巨大时，a数组将会很大以至于会被存储在很多个页面上（a[0] 与a[1]不在同一页上），这时候下面循环发生缺页中断的可能性与次数远高于上面循环，尽管他们的算法复杂度、运行结果完全一致。